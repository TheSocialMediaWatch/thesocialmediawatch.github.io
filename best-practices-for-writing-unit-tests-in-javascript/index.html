<!doctype html><html lang=en dir=auto><head><title>Best Practices for Writing Unit Tests in JavaScript</title>
<link rel=canonical href=https://various.googlexy.com/best-practices-for-writing-unit-tests-in-javascript/><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><meta name=description content><meta name=author content><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://various.googlexy.com/logo.svg><link rel=icon type=image/png sizes=16x16 href=https://various.googlexy.com/logo.svg><link rel=icon type=image/png sizes=32x32 href=https://various.googlexy.com/logo.svg><link rel=apple-touch-icon href=https://various.googlexy.com/logo.svg><link rel=mask-icon href=https://various.googlexy.com/logo.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://various.googlexy.com/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="All the knowledge is here!"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://various.googlexy.com/"><meta name=twitter:card content="summary"><meta name=twitter:title content="All the knowledge is here!"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"All the knowledge is here!","url":"https://various.googlexy.com/","description":"","thumbnailUrl":"https://various.googlexy.com/logo.svg","sameAs":[]}</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6194699946397512" crossorigin=anonymous></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://various.googlexy.com/ accesskey=h title="Home (Alt + H)"><img src=https://various.googlexy.com/logo.svg alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://various.googlexy.com/articles/ title=Articles><span>Articles</span></a></li><li><a href=https://various.googlexy.com/categories/ title=Categories><span>Categories</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Best Practices for Writing Unit Tests in JavaScript</h1><div class=post-description></div></header><figure class=entry-cover><img loading=eager src=https://various.googlexy.com/images/programming.jpeg alt></figure><br><div class=post-content><p>Unit testing plays a crucial role in modern software development. As JavaScript applications become more complex, ensuring that each part of your code functions as expected is critical to maintaining quality and reducing bugs. Writing effective unit tests can be challenging, but by following best practices, developers can ensure their tests are meaningful, maintainable, and provide long-term benefits. In this post, we will dive into some of the best practices for writing unit tests in JavaScript.</p><h2 id=why-unit-testing-is-important>Why Unit Testing is Important</h2><p>Unit testing involves testing individual components or functions of your code to verify that they work correctly in isolation. It ensures that changes made to your code don&rsquo;t inadvertently introduce new bugs or break existing functionality. Some of the primary benefits of unit testing include:</p><ul><li><strong>Catch Bugs Early</strong>: Unit tests help you identify bugs early in the development process, making it easier to fix them before they affect other parts of the application.</li><li><strong>Document Code Behavior</strong>: Well-written tests serve as documentation for how your functions and components are expected to behave.</li><li><strong>Facilitate Refactoring</strong>: With unit tests in place, you can refactor your code with confidence, knowing that the tests will catch any unintended side effects of the changes.</li><li><strong>Improve Code Quality</strong>: Writing tests forces developers to write modular, decoupled, and maintainable code. It promotes better design practices, making your code more readable and understandable.</li></ul><h2 id=setting-up-a-unit-testing-framework>Setting Up a Unit Testing Framework</h2><p>Before you start writing unit tests, it&rsquo;s essential to choose a testing framework. JavaScript has several frameworks available, with some of the most popular being:</p><ol><li><strong>Jest</strong>: A widely-used testing framework developed by Facebook. Jest is known for its simplicity and speed, making it ideal for both beginner and experienced developers.</li><li><strong>Mocha</strong>: Mocha is a flexible and feature-rich testing framework that works well with other libraries like Chai for assertions.</li><li><strong>Jasmine</strong>: An older framework that comes with a built-in assertion library. Jasmine is often used for behavior-driven development (BDD).</li><li><strong>Ava</strong>: A minimalistic framework that focuses on simplicity and parallel test execution.</li></ol><p>For this guide, we&rsquo;ll use <strong>Jest</strong> as an example, but the practices we discuss can be applied to any testing framework.</p><p>To set up Jest, simply run:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>npm install --save-dev jest
</span></span></code></pre></div><p>Then, add the following script to your <code>package.json</code> file to easily run your tests:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=s2>&#34;scripts&#34;</span><span class=err>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;test&#34;</span><span class=p>:</span> <span class=s2>&#34;jest&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now you can run your tests with the <code>npm test</code> command.</p><h2 id=best-practices-for-writing-unit-tests>Best Practices for Writing Unit Tests</h2><h3 id=1-write-small-focused-tests>1. Write Small, Focused Tests</h3><p>Each unit test should only test a single function or component. Writing small, focused tests makes it easier to isolate issues when they arise and ensures that your tests are easy to maintain.</p><p>For example, if you have a function that adds two numbers together, your unit test should only verify that the addition happens correctly. Avoid adding additional tests or logic within the same unit test. Here&rsquo;s an example of a well-written test for a simple function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>add</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>test</span><span class=p>(</span><span class=s1>&#39;adds two numbers correctly&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>expect</span><span class=p>(</span><span class=nx>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)).</span><span class=nx>toBe</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><p>In this test, the only thing being tested is whether the <code>add</code> function works correctly for two numbers. Keep each test case simple and focused on one specific behavior.</p><h3 id=2-keep-tests-independent>2. Keep Tests Independent</h3><p>Unit tests should be independent of each other, meaning that one test&rsquo;s result should not rely on the success or failure of any other test. This ensures that if one test fails, it doesn&rsquo;t cause a cascade of failures, making it harder to identify the root cause.</p><p>To ensure test independence, avoid shared state between tests. For example, don’t use global variables or modify objects in ways that could affect other tests. Instead, set up the necessary state for each test within the test itself using setup functions like <code>beforeEach</code> or <code>beforeAll</code> (available in Jest).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>let</span> <span class=nx>counter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>beforeEach</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>counter</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>test</span><span class=p>(</span><span class=s1>&#39;increments counter by 1&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>counter</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>expect</span><span class=p>(</span><span class=nx>counter</span><span class=p>).</span><span class=nx>toBe</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>test</span><span class=p>(</span><span class=s1>&#39;counter starts at 0&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>expect</span><span class=p>(</span><span class=nx>counter</span><span class=p>).</span><span class=nx>toBe</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><p>By initializing the <code>counter</code> variable in the <code>beforeEach</code> hook, each test starts with a clean state, ensuring the tests don’t interfere with each other.</p><h3 id=3-name-tests-clearly-and-descriptively>3. Name Tests Clearly and Descriptively</h3><p>Test names should clearly describe what behavior is being tested. Descriptive names help developers quickly understand the purpose of each test without having to read through the implementation.</p><p>A good test name might look like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=nx>test</span><span class=p>(</span><span class=s1>&#39;should return true when the user is logged in&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>expect</span><span class=p>(</span><span class=nx>isLoggedIn</span><span class=p>()).</span><span class=nx>toBe</span><span class=p>(</span><span class=kc>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><p>This test name clearly indicates that it&rsquo;s testing the behavior of the <code>isLoggedIn</code> function, specifically ensuring that it returns <code>true</code> when the user is logged in.</p><h3 id=4-test-edge-cases-and-boundary-conditions>4. Test Edge Cases and Boundary Conditions</h3><p>While it&rsquo;s important to test the normal behavior of your functions, it&rsquo;s equally important to test edge cases and boundary conditions. These are situations that are less common but can lead to bugs if not properly handled.</p><p>Consider testing:</p><ul><li><strong>Null or undefined values</strong>: Does your function handle cases where the input is missing or null?</li><li><strong>Empty strings or arrays</strong>: Does your function behave correctly when given an empty string or array as input?</li><li><strong>Maximum or minimum values</strong>: If your function operates on numbers, does it correctly handle extremely large or small values?</li></ul><p>Here’s an example of testing an edge case where an array is empty:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kd>function</span> <span class=nx>findMax</span><span class=p>(</span><span class=nx>numbers</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>numbers</span><span class=p>.</span><span class=nx>length</span> <span class=o>===</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=kc>null</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nb>Math</span><span class=p>.</span><span class=nx>max</span><span class=p>(...</span><span class=nx>numbers</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>test</span><span class=p>(</span><span class=s1>&#39;returns null for an empty array&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>expect</span><span class=p>(</span><span class=nx>findMax</span><span class=p>([])).</span><span class=nx>toBeNull</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><h3 id=5-use-mocks-and-stubs-for-external-dependencies>5. Use Mocks and Stubs for External Dependencies</h3><p>In unit testing, it’s important to isolate the unit being tested. This often means mocking or stubbing external dependencies like API calls, database queries, or other services.</p><p>Jest provides built-in support for mocks and spies, allowing you to replace actual implementations with mock functions. This is especially useful when testing code that interacts with third-party services or libraries that are outside your control.</p><p>Here’s an example of how to mock a function in Jest:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>const</span> <span class=nx>fetchData</span> <span class=o>=</span> <span class=nx>jest</span><span class=p>.</span><span class=nx>fn</span><span class=p>().</span><span class=nx>mockResolvedValue</span><span class=p>({</span> <span class=nx>data</span><span class=o>:</span> <span class=s1>&#39;some data&#39;</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>test</span><span class=p>(</span><span class=s1>&#39;fetches data correctly&#39;</span><span class=p>,</span> <span class=kr>async</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=kr>await</span> <span class=nx>fetchData</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=nx>expect</span><span class=p>(</span><span class=nx>result</span><span class=p>.</span><span class=nx>data</span><span class=p>).</span><span class=nx>toBe</span><span class=p>(</span><span class=s1>&#39;some data&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><p>In this example, <code>fetchData</code> is mocked to always return a resolved promise with specific data. This allows you to test the code that relies on <code>fetchData</code> without actually making a network request.</p><h3 id=6-use-snapshot-testing>6. Use Snapshot Testing</h3><p>Snapshot testing is a technique where the output of a function or component is saved as a snapshot and compared with future outputs to ensure they remain the same. This is especially useful for testing UI components or complex data structures.</p><p>Jest has built-in support for snapshot testing, which is as simple as calling <code>expect()</code> with the <code>.toMatchSnapshot()</code> matcher. Here’s an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-javascript data-lang=javascript><span class=line><span class=cl><span class=kr>import</span> <span class=p>{</span> <span class=nx>render</span> <span class=p>}</span> <span class=nx>from</span> <span class=s1>&#39;@testing-library/react&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>import</span> <span class=nx>MyComponent</span> <span class=nx>from</span> <span class=s1>&#39;./MyComponent&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>test</span><span class=p>(</span><span class=s1>&#39;matches snapshot&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=p>{</span> <span class=nx>asFragment</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>render</span><span class=p>(</span><span class=o>&lt;</span><span class=nx>MyComponent</span> <span class=o>/&gt;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>expect</span><span class=p>(</span><span class=nx>asFragment</span><span class=p>()).</span><span class=nx>toMatchSnapshot</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><p>In this case, the first time the test runs, Jest will save a snapshot of the rendered component. In future test runs, Jest will compare the rendered component against the saved snapshot to detect any changes.</p><h3 id=7-keep-tests-fast-and-efficient>7. Keep Tests Fast and Efficient</h3><p>Unit tests should be fast to run. The quicker your tests execute, the more frequently you can run them, and the easier it is to catch bugs. Avoid tests that take a long time to execute, such as those that involve complex operations, network requests, or interactions with databases.</p><p>Here are a few tips to keep your tests fast:</p><ul><li><strong>Mock slow operations</strong>: If your code makes network requests or performs heavy computations, mock these operations to avoid delays during testing.</li><li><strong>Avoid unnecessary setup</strong>: If you don’t need certain parts of your application to run during the test, don’t set them up. Only initialize what’s necessary for each test case.</li><li><strong>Run tests in parallel</strong>: Some testing frameworks, like Jest, run tests in parallel by default, which can drastically speed up the testing process.</li></ul><h3 id=8-continuously-integrate-your-tests>8. Continuously Integrate Your Tests</h3><p>Running tests on your local machine is important, but it&rsquo;s just as crucial to set up continuous integration (CI) to run your tests automatically. CI tools like <strong>GitHub Actions</strong>, <strong>Travis CI</strong>, and <strong>CircleCI</strong> can run your tests every time you push changes to a repository, ensuring that your codebase remains stable.</p><p>By integrating tests into your CI pipeline, you can immediately identify when a change breaks existing functionality, helping maintain the integrity of your codebase.</p><h3 id=9-review-and-refactor-tests-regularly>9. Review and Refactor Tests Regularly</h3><p>Just like your application code, test code needs to be maintained and refactored over time. Review your tests regularly to ensure they remain relevant and don’t become outdated as the application evolves.</p><p>When refactoring your application code, take the time to review and refactor your tests as well. Make sure they still accurately reflect the behavior of your application and improve them when necessary.</p><h2 id=conclusion>Conclusion</h2><p>Unit testing is a vital practice for maintaining high-quality JavaScript applications. By following best practices such as writing small, focused tests, testing edge cases, using mocks, and keeping tests fast, developers can ensure that their tests provide real value. Unit tests not only help catch bugs early but also serve as a safety net when refactoring code and adding new features.</p><p>Remember that writing tests is an ongoing process. As your codebase grows and changes, your tests will need to evolve too. By adopting these best practices and continuously improving your testing strategy, you’ll build a more robust, maintainable, and reliable JavaScript application.</p></div><footer class=post-footer><nav class=paginav>Category:<a href=https://various.googlexy.com/categories/programming/>Programming</a></nav><nav class=paginav><a class=prev href=https://various.googlexy.com/best-practices-for-writing-secure-code-in-2025/><span class=title>« Prev</span><br><span>Best Practices for Writing Secure Code in 2025</span>
</a><a class=next href=https://various.googlexy.com/best-resources-for-learning-web-development-in-2025/><span class=title>Next »</span><br><span>Best Resources for Learning Web Development in 2025</span></a></nav><nav class=paginav><ul style=list-style-type:none><li><small>See Also</small></li><li><ul style=list-style-type:none><li><small><a href=/exploring-functional-programming-in-scala/>Exploring Functional Programming in Scala</a></small></li><li><small><a href=/introduction-to-networking-for-programmers/>Introduction to Networking for Programmers</a></small></li><li><small><a href=/how-to-use-kubernetes-for-container-orchestration/>How to Use Kubernetes for Container Orchestration</a></small></li><li><small><a href=/the-fundamentals-of-network-programming/>The Fundamentals of Network Programming</a></small></li><li><small><a href=/reach-your-full-potential-challenges-every-programmer-should-undertake/>Reach Your Full Potential: Challenges Every Programmer Should Undertake</a></small></li></ul></li></ul></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://various.googlexy.com/>All the knowledge is here!</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>